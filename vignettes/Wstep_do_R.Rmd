---
title: "Wstęp do R"
date: 2015.02.02
output:
  html_document:
  highlight: tango
---
<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{Wstęp do R}
-->
```{r, results = 'hide', message = FALSE, warning = FALSE, echo = FALSE}
library(ZPD)
```

Podstawowe różnice między R, a innymi programami statystycznymi:

* Dostępny wyłączeni _syntax_, brak możliwości "wyklikiwania" analiz.
    * _RStudio_ wprowadza istotne ułatwienia, w szczególności uzupełnianie składni i łatwy dostęp do manuali.
    
* Praca z wieloma zbiorami danych jednocześnie:
    * W większości programów statystycznych możemy mieć w danym momencie wczytany tylko jeden zbiór danych.
        * Operacje na danych polegają na modyfikacji i dodawaniu nowych zmiennych do tego zbioru.
    * w R z natury rzeczy pracujemy z wieloma zbiorami danych i/lub wieloma kopiami tego samego zbioru.
        * Koncepcja _zmiennej_ w rozumieniu języka programowania.

# Zmienne

_Zmienna_ przechowuje:

* zbiór danych (zwany w R _ramką danych_/_data frame_);
* lub ciąg wartości (o dowolnej długości, z 0 włącznie);
* lub tablicę, lub funkcję, lub formułę, itp. cuda, którymi nie będziemy się zajmować.

Nas interesować będą głównie _ramki danych_ (czasem jeszcze ciągi wartości).

Ciągi wartości tworzymy funkcją `c(wartość1, ...)`. Przy tym zakres liczb można podawać w skróconej formie `od:do`:

```{r}
ciagWartosci1 = c('a', 'b', 'c', 'd', 'e')
ciagWartosci1

ciagWartosci2 = c(1:5)
ciagWartosci2

ciagWartosci3 = c(1:2, 5:7)
ciagWartosci3
```

_Ramkę danych_ wczytujemy z pliku bądź tworzymy jako zestaw kolumn (gdzie każda kolumna to ciąg wartości o tej samej długości).
```{r}
mojeDane = data.frame('kolumna1' = ciagWartosci1, 'kolumna2' = ciagWartosci2, 'kolumna3' = ciagWartosci3)
mojeDane
```

# Wczytywanie i zapisywanie danych

## Do plików R

Zaletą formatu danych R jest to, że dane zapisują się i wczytują bardzo szybko, jak również niewielki rozmiar plików na dysku (są kompresowane).
Jeśli będzie się przez chwilę pracować z danymi w R (np. złączając je ze sobą i przekształcając), warto korzystać właśnie z tego formatu, a dopiero ostatecznie przygotowane dane zapisać w jakimś przenośnym formacie.

Do zapisu i odczytu służą funkcje:

* zapis: `save(nazwaZmiennej1, ..., file = 'ścieżka do pliku.RData')` - zapisuje wskazane zmienne (dowolną ilość) do pliku;
* odczyt: `load('ścieżka do pliku.RData')` - wczytuje zmienne z pliku; zostaną wczytane z takimi nazwami, z jakimi zostały zapisane.
```{r}
# zapis
mojeDane = data.frame('zmienna1' = c(1:3), 'zmienna2' = c('a', 'b', 'c'))
ciagWartosci = c('a', 'b', 'c')
save(mojeDane, ciagWartosci, file = '~/przyklad.RData')

# odczyt
rm(mojeDane, ciagWartosci) # usuńmy zmienne, aby zobaczyć, że faktycznie się wczytają
load('~/przyklad.RData')
```

## Do plików CSV

CSV jest najbardziej przenośnym formatem - daje się odczytać i zapisać w praktycznie każdym programie statystycznym.

Do zapisu i odczytu plików CSV "w formacie Excela" służą w R funkcje:

* zapis: `write.csv2(ramkaDanych, 'ścieżka do pliku.csv', row.names = F, na = '', fileEncoding = 'Windows-1250')`;
* odczyt: `read.csv2('ścieżka do pliku.csv', stringsAsFactors = FALSE)` (przy czym tym razem wynik działania funkcji należy przypisać do zmiennej).

Istnieją też alternatywne funkcje, zapisujące/odczytujące z użyciem innych ustawień (np. innego separatora kolumn, innego separatora dzisiętnego, itp.) - dociekliwy czytelnik łatwo wyszuka.

```{r}
# zapis
mojeDane = data.frame('zmienna1' = c(1:3), 'zmienna2' = c('a', 'b', 'c'))
write.csv2(mojeDane, '~/przyklad.RData', row.names = F, na = '', fileEncoding = 'Windows-1250')

# odczyt
mojeDane2 = read.csv2('~/przyklad.RData', stringsAsFactors = FALSE)
mojeDane2
```

# Operacje na ramkach danych

Jeśli masz już jakieś doświadczenie z przekształcaniem danych w R - zapomnij, co wiesz.

Korzystając z bazy będziemy używać składni pochodzącej z pakietu _dplyr_, ponieważ jest ona spójna (a więc łatwiejsza do nauki), jak również działa znacznie szybciej.

Wyróżnić można kilka ogólnych grup operacji na _ramkach danych_:

* wybieranie wierszy
* wybieranie kolumn
* zmiana nazw kolumn
* modyfikowanie / tworzenie nowych kolumn
* agregacja
* sortowanie
* złączanie kilku _ramek danych_
* przekształcanie między postaciami długo i szeroką

Rozbudowane opisy możliwych operacji wraz z przykładami można znaleźć pod adresem http://zpd.ibe.edu.pl/?id=dplyr

## Łączenie ze sobą wielu operacji

Operacje można wykonywać pojedynczo:
```{r, eval = FALSE}
mojeDane = operacja1(mojeDane)
mojeDane = operacja2(mojeDane)
```

Można też łączyć je ze sobą w ciągi używając operatora `%>%`:
```{r, eval = FALSE}
mojeDane = operacja1(mojeDane) %>%
  operacja2()
```

Tak naprawdę operator `%>%` powoduje przekazanie tego, co zastanie po lewej stronie jako pierwszy argument funkcji, którą ma po prawej stronie.

## Wybieranie wierszy

### wg wartości kolumn

`filter(warunek1, ...)`

* warunków może być dowolnie wiele
* łączą się ze sobą przez koniunkcję
    * chcąc uzyskać alternatywę łączymy ze sobą warunki operatorem `|` (pojedynczej pionowej kreski)
* dostępne operatory:
    * `%in%` zawieranie się w ciągu wartości (braki danych nie spełniają warunku)
    * `==` tożsamość (__uwaga!__ braki danych spełniają warunek)
    * `<, >, <=, >=` (__uwaga!__ braki danych spełniają warunek)
    * `is.na()` - czy brak danych
    * `grepl(wyrażenie, kolumna)` dopasowanie do wyrażenia regularnego
    * `!` negacja
* stałe logiczne:
    * `T`, `TRUE` - prawda
    * `F`, `FALSE` - fałsz

Poćwiczmy na zbiorze danych _mtcars_ - jest to wbudowana w R _ramka danych_ przeznaczona do celów dydaktycznych i testowych.
```{r}
# przepiszmy nazwy modeli do oddzielnej kolumny (na razie nieważne, w jaki sposób)
mtcars = mtcars %>% 
   mutate(model = rownames(mtcars))
# obejrzyjmy całą ramkę danych
mtcars

# odfiltrujmy tylko te modele, które mają 4 cylindry i moc powyżej 100 koni mechanicznych
mtcars %>% filter(cyl %in% c(4), hp > 100, !is.na(hp))

# odfiltujmy tylko te o mocy powyżej 180 koni mechanicznych 
# lub czasie sprintu na 1/4 mili poniżej 17 sekund
mtcars %>% filter(hp > 180 | qsec < 17, !is.na(hp), !is.na(qsec))
```

### wg numerów wierszy

`slice(numery_wierszy)`

```{r}
# wybieramy wiersze od 1 do 5
mtcars %>% slice(1:5)
```

## wybieranie kolumn

`select(kolumna1, ...)`

```{r}
# wybieramy z mtcars tylko kolumny "mpg" i "cyl"
mtcars %>% select(mpg, cyl)
```

## zmiana nazw kolumn

`rename(nowaNazwa = staraNazwa, ...)`

```{r}
# zmieniamy nazwę kolumny "mpg"" na "mile_na_galon"
# (i wyświetlamy tylko 3 pierwsze wiersze)
mtcars %>% 
  rename(mile_na_galon = mpg) %>%
  slice(1:3)
```

## modyfikowanie / tworzenie nowych kolumn

`mutate(nazwaKolumny1 = definicjaKolumny1, ...)`

W definicji możemy stosować:

* operatory arytmetyczne (`+, -, *, /, ^`)
* funkcje operujące na liczbach, np. `mean()`, `min()`, `max())`, `median()`
    * aby pomijać przy obliczaniu braki danych, należy wywoływać je z parametrem `na.rm = TRUE` - patrz przykłady
* funkcje operujące na łańcuchach znaków, np.:
    * `paste0(kolumnaLubStala1, ...)` - złączanie tekstów
    * `gsub(wyrazenieRegularne, zamiana, kolumna)` - znajdź i zamień

```{r}
# obliczamy liczbę kilometrów przejechanych na galonie benzyny jako wielokrotność najgorszego wyniku
mtcars %>% mutate(iloraz = mpg / min(mpg))
```

Jeśli tworzona kolumna będzie się nazywać tak, jak kolumna już istniejąca, wtedy istniejąca kolumna zostanie nadpisana nowymi wartościami (zmodyfikowana).

## sortowanie

`arrange(kolumna1, ...)`

```{r}
# tworzymy zmienną iloraz, jak w porprzednim przykładzie i sortujemy po jej wartości
# wyświetlamy tylko pirwsze 5 wierszy
mtcars %>% 
  mutate(iloraz = mpg / min(mpg)) %>%
  arrange(iloraz) %>%
  slice(1:5)

# tak samo, tylko malejąco
mtcars %>% 
  mutate(iloraz = mpg / min(mpg)) %>%
  arrange(desc(iloraz)) %>%
  slice(1:5)
```

## agregacja

`group_by(kolumna1, ...)`

Grupuje _ramkę danych_ wg wartości zadanych kolumn.

`summarize(nazwaKolumny1 = definicjaKolumny1)`

Tworzy nową _ramkę danych_, która:

* będzie zawierać tylko kolumny, wg których dokonano agregacji oraz kolumny zdefiniowane w funkcji `summarize()`
* będzie zawierać tylko po jednym wierszu dla każdej grupy.

Definiując nowe kolumny można użyć specjalnej funkcji `n()`, która zwraca liczbę obserwacji w danej grupie.

```{r}
# obliczmy min, max oraz średnią liczbę mil przejechanych na galonie beznyny 
# w podziale na liczbę cylindrów i typ skrzyni biegów;
# dołączmy informację o liczbeności każdej grupy
mtcars %>%
  group_by(cyl, am) %>%
  summarize(min = min(mpg), max = max(mpg), sr = mean(mpg), liczba = n())
```

## złączanie kilku _ramek danych_

Istnieje wiele rodzajów złączeń - patrz http://zpd.ibe.edu.pl/?id=

Złączenia pomiędzy ramkami danych następują na podstawie wartości kolumn **o tych samych nazwach**. Jeśli kolumny w ramkach danych nazywają się tak samo, ale nie chcemy złączać na podstawie ich wartości, trzeba je przed złączeniem przezwać (np. mamy wyniki dwóch części egzaminu w oddzielnych ramkach danych - w każdej w kolumnie _wynik_ - przed ich złączeniem należałoby zmienić nazwę przynajmniej jednej z nich).

Do złączania ramek danych służą funkcje:

`inner_join(ramka_danych1, ramka_danych2)`
`left_join(ramka_danych1, ramka_danych2)`
`full_join(ramka_danych1, ramka_danych2)`

## przekształcanie między postacią długą i szeroką

### z postaci szerokiej na długą

`reshape2::melt(ramka_danych, id.vars = nazwy_zmiennych_do_pozostawienia, variable.name = nazwaKolumnyNazwy, value.name = nazwaKolumnyWartosci)`

```{r}
# chcemy przekształcić _ramkę danych_ mtcars tak, by mieć jedynie zmienne: _model_, _parametr_ i _wartosc_
# wynik będzie miał bardzo dużo wierszy, więc obcinamy do 20
reshape2::melt(mtcars, id.vars = c('model'), variable.name = 'parametr', value.name = 'wartosc') %>%
  slice(1:20)
```

### z postaci długiej do szerokiej

`reshape2::dcast(ramka_danych, formuła)`

Formuła definiuje, wartości których kolumn przepisane zostaną w nowe kolumny. Ma ona postać:

`kolumnaWiersza1 + ... ~ kolumnaWkolumny1 + ...`

```{r}
# przekształciliśmy mtcars do postaci długiej:
mtcars = reshape2::melt(mtcars, id.vars = c('model'), variable.name = 'parametr', value.name = 'wartosc')

# chcemy przywrócić im postać szeroką, a więc przepisać wartości zmiennej 'parametr' w kolumny:
reshape2::dcast(mtcars, model ~ parametr)
```
